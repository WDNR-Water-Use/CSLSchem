---
title: "CSLS Calcification"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{chem_calcification}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
library(knitr)
library(CSLSchem)
library(dplyr)
library(stringr)
library(lubridate)
library(reshape2)
library(ggplot2)
library(extrafont)
library(stringr)

text_size    <- 12
lakes        <- c("Pleasant", "Long", "Plainfield")
water_chem   <- CSLSdata::water_chem
start_date   <- as_datetime(mdy("10-01-2018"))
end_date     <- as_datetime(mdy("09-30-2019"))

fig_width  <- 6.5
fig_height <- 4
```

## Overview

Here, we're trying to replicate the approach for calculating lake calcification
rates from McConnoughey et al. (1994). However, our net annual rates are
near-zero, which is difficult to square with our solute mass balances. Are we
misunderstanding something about how to calculate calcification? Are we perhaps
running into trouble because Mg does not behave conservatively enough at our
study lakes?

## Seasonal Variations in Anions

First, let's look at the data we have about the concentration of major cations
and anions at each lake over time (as in Fig. 2 in McConnaughey et al., 1994).

<br>

Note that values for Alkalinity, Calcium, and Magnesium are ~50% higher at
Pleasant and Plainfield Lakes than in McConnaughey et al., while Long Lake is
similar but slighly lower than the values they present for Williams Lake.

```{r cations01, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
# Filter to only anions/cations of interest

parameters <- c("MAGNESIUM TOTAL RECOVERABLE",
                "ALKALINITY TOTAL CACO3",
                "CALCIUM TOTAL RECOVERABLE",
                "SODIUM TOTAL RECOVERABLE",
                "SULFATE TOTAL",
                "CHLORIDE")
plot_names <- c("Mg", "Alkalinity", "Ca", "Na", "SO4", "Cl")

# Get solutes of interest
  C_solutes <- NULL
  for (solute in parameters) {
    C_solute  <- filter_parameter(water_chem, solute)
    C_solute  <- C_solute %>% filter(.data$site_type == "lake")
    C_solute  <- interpolate_chem_values(C_solute, dt = "day") %>%
                 select(.data$lake, .data$date, .data$site_type, .data$result)
    C_solute$description <- solute
    C_solutes <- rbind(C_solutes, C_solute)
  }

# Convert from mg/L to meq/L
ions        <- merge(C_solutes, mgTOmeq, all.x = TRUE)
ions$result <- ions$result*ions$mgTOmeq*1000
ions$lake   <- factor(ions$lake, levels = lakes)

# Sub long descriptions with shorter names for plotting
for (i in 1:length(parameters)) {
  ions$description <- str_replace_all(ions$description,
                                      parameters[i], 
                                      plot_names[i])
}

# Plot
plot_obj <- ggplot(ions) +
            geom_point(aes(x = .data$date, 
                          y = .data$result,
                          color = description),
                      size = 1.5) +
            geom_line(aes(x = .data$date, 
                          y = .data$result,
                          color = description)) +
            facet_grid(~lake) +
            labs(x = "", y = "ueq/L") +
            scale_x_datetime(breaks = "6 months",
                             minor_breaks = "2 months",
                             date_labels = "%b-%y") +
            scale_color_brewer(name = "",
                               palette = "Set2") +
            theme_bw() + 
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  legend.position = "top")
plot_obj

```

<br>

Next, let's look at monthly values of the major cations (Mg++, Ca++, Na+, and
K+) for Oct 2018 - Sept 2019 realative to the mean Jan/Feb values (as in Fig. 3
in McConnaughey et al., 1994). The goal of this is to visually identify cations
which drop during spring dilution, stabilize over the summer, then rise over
winter. This would indicate that, to a first approximation, seasonal
fluctuations in those cations reflect dilution.

<br>

None of the cations are very conservative, but **at a first approximation, Mg or
Na are the most conservative** in all lakes.

```{r cations, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
# Filter to only anions/cations of interest

parameters <- c("MAGNESIUM TOTAL RECOVERABLE",
                "SODIUM TOTAL RECOVERABLE",
                "CALCIUM TOTAL RECOVERABLE",
                "POTASSIUM TOTAL RECOVERABLE")
plot_names <- c("Mg", "Na", "Ca", "K")

# Get solutes of interest
C_solutes <- NULL
for (solute in parameters) {
  C_solute  <- filter_parameter(water_chem, solute)
  C_solute  <- C_solute %>% filter(.data$site_type == "lake")
  C_solute  <- interpolate_chem_values(C_solute, dt = "day") %>%
    select(.data$lake, .data$date, .data$site_type, .data$result)
  C_solute$description <- solute
  C_solutes <- rbind(C_solutes, C_solute)
}
  
# Convert from mg/L to meq/L
ions        <- merge(C_solutes, mgTOmeq, all.x = TRUE)
ions$result <- ions$result*ions$mgTOmeq
ions$lake   <- factor(ions$lake, levels = lakes)

# Sub long descriptions with shorter names for plotting
for (i in 1:length(parameters)) {
  ions$description <- str_replace_all(ions$description,
                                      parameters[i], 
                                      plot_names[i])
}

# Find monthly average values across entire timeseries
ions <- ions %>%
        filter(.data$date >= start_date,
               .data$date <= end_date) %>%
        select(.data$lake, .data$date, .data$description, .data$result)

# Compare to mean Jan/Feb values
mean_ions   <- ions %>%
               filter(month(.data$date) %in% c(1, 2)) %>%
               group_by(.data$lake, .data$description) %>%
               summarise(mean = mean(.data$result, na.rm = TRUE)) %>%
               ungroup()
ions        <- merge(ions, mean_ions, by = c("lake", "description"))
ions$result <- ions$result/ions$mean

# Plot
plot_obj <- ggplot(ions) +
            geom_line(aes(x = date, 
                          y = result,
                          color = description),
                      size = 1) +
            facet_grid(~lake) +
            labs(x = "", y = "%(Jan,Feb) value") +
            scale_x_datetime(expand = c(0,0),
                             breaks = "2 months",
                             minor_breaks = "1 month",
                             date_labels = "%b") +
            scale_y_continuous(breaks = 0.1*c(5:12),
                               labels = scales::percent_format(accuracy = 1)) +
            scale_color_brewer(name = "",
                               palette = "Set2") +
            theme_bw() + 
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  legend.position = "top")
plot_obj

```

## Pairwise Comparisons

Pairwise comparisons can be used to further investigate quasi-conservative
behavior of cations/anions (e.g., Fig. 4 and Fig. 6 in McConnaughey et al.,
1994). Lake-water values for semi-conservative ions should fall near a dilution
line connecting most upgradient groundwater samples with precipitation samples.

In these plots, PFL-09 (a well with unusually high cations/anions) is not shown.

### Mg vs. Ca

Precipitation and groundwater samples lie along a nearly 1:1 line, with lake
samples falling slightly below (Ca is slightly lower than Mg) for Pleasant Lake.
This is what we expect to see with calcification. Long Lake and Plainfield Lake
do not show as much evidence of calcification.

```{r MgCa, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "CALCIUM TOTAL RECOVERABLE"),
           text_size = text_size)
```


### Mg vs. Na

If we assume Mg is semi-conservative, then Na is not. Long Lake and especially
Plainfield also show evidence of an additional source of Na to the lake (likely
explanation: road salt).

```{r MgNa, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "SODIUM TOTAL RECOVERABLE"),
           text_size = text_size)
```

### Mg vs. K

If we assume Mg is semi-conservative, then K is not. Long and Plainfield Lakes
again show signs of an unaccounted-for source of potassium to the lake.

```{r MgK, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "POTASSIUM TOTAL RECOVERABLE"),
           text_size = text_size)
```

### Mg vs. Cl

If we assume Mg is semi-conservative, then Cl is not. In Long Lake and
especially Plainfield Lake, there appears to be an unaccounted-for source of
chloride to the lake (likely explanation: road salt).

```{r MgCl, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "CHLORIDE"),
           text_size = text_size)
```

### Mg vs. Alk

As in the Mg:Ca plots, calcification should cause the lake to fall slightly
below the regression line (as in Fig. 6, McConnaughey et al. (1994)).

```{r MgAlk, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "ALKALINITY TOTAL CACO3"),
           text_size = text_size)
```

## Calcification

Ok, so let's go with Mg as our "conservative" solute! Now let's see how much
calcification we might expect based on Eq. 7 in McConnaughey et al., 1994. The
equation is written as:

\begin{align}
\tag{1}
calcification = -\frac{d}{dt}[Ca]\frac{Mg_{avg}}{Mg} + GW(Ca)
\end{align}

Based on their discussion of groundwater chemical fluxes on page 1327, we
interpreted this as:

\begin{align}
\tag{2}
calcification = -\frac{d}{dt}[Ca_{lake}]\frac{[Mg_{lake,avg}]}{[Mg_{lake}]} + \frac{\frac{[Ca_{GW}]}{[Mg_{GW}]}[Mg_{lake}]}{V_{lake}/GW_{in}} - \frac{\frac{[Ca_{lake}]}{[Mg_{lake}]}[Mg_{lake}]}{V_{lake}/GW_{out}}
\end{align}

where $V_{lake}$ is the lake volume, $GW_{in}$ is the annual groundwater inflow
rate, and $GW_{out}$ is the annual groundwater outflow rate. However, we are not
sure this is a correct interpretation.

<br>

With our best interpretation of calcification in hand, we set out to visualize
the same information as is in Fig. 5 of McConnaughey et al. (1994). Notes about
this figure:

  * Regression lines of Ca & Alk cover the period Oct-Apr, as in McConnaughey et al.
  * The slope of the regression line for Williams Lake was ~120 uM/yr, these are
  ~126 uM/yr (Long), 207 uM/yr (Pleasant), and 322 uM/yr (Plainfield).
  * The difference between projected Ca & Alk values and actual observed summer 
  values was ~160 uM for Williams Lake.
  * McConnaughey et al. regularly mention that their values are "dilution
  normalized". I'm not sure what that means; these lake concentrations are not
  transformed at all.

Overall, these calcification rates seem to come from the same planet as the
rates in McConnaughey et al. (1994). Rates are a bit higher at Pleasant Lake and
Plainfield Lake than at Williams Lake; Long Lake is a little below what was
calculated for Williams Lake.

```{r Calc, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=5, fig.align="center"}
# Calculate calcification
calcify <- calculate_calcification() %>%
           select(.data$date, .data$lake, .data$description,
                  .data$calcification, .data$X_lake)
colnames(calcify) <- c("date", "lake", "description", 
                       "Calcification (uM/yr)", "Lake (uM)")

# Rearrange and rename
melt_calcify <- melt(calcify, id.vars = c("date", "lake", "description"))
melt_calcify$description <- str_replace_all(melt_calcify$description, 
                                           "ALKALINITY TOTAL CACO3", 
                                           "Alkalinity")
melt_calcify$description <- str_replace_all(melt_calcify$description, 
                                           "CALCIUM TOTAL RECOVERABLE", 
                                           "Calcium")
melt_calcify$variable <- factor(melt_calcify$variable, 
                               levels = c("Lake (uM)", "Calcification (uM/yr)"))

predictions <- NULL
for (pred_date in c("06-01-2019", "07-01-2019", "08-01-2019")) {
this_date <- melt_calcify %>%
             filter(.data$date <= as_datetime(mdy("04-30-2019")),
                    .data$variable == "Lake (uM)") %>%
             group_by(.data$lake, .data$description) %>%
             do(lm(value ~ date, data = .) %>%
                  predict(., data.frame(date = as_datetime(mdy(pred_date)))) %>%
                  data_frame(date = as_datetime(mdy(pred_date)), value = .)) %>%
             ungroup()
predictions <- bind_rows(predictions, this_date)
}
predictions$variable <- "Lake (uM)"
predictions <- merge(predictions, 
                     melt_calcify, 
                     by = c("date", "lake", "description", "variable"),
                     all.x = TRUE)
predictions <- predictions %>%
               mutate(value = round(.data$value.x - .data$value.y, digits = 2),
                      plot_y = .data$value.y + 0.5*.data$value)

predictions <- predictions %>%
               filter((.data$date == as_datetime(mdy("06-01-2019")) & 
                         .data$lake == "Long") |
                        (.data$date == as_datetime(mdy("07-01-2019")) & 
                           .data$lake == "Plainfield") |
                        (.data$date == as_datetime(mdy("08-01-2019")) & 
                           .data$lake == "Pleasant"))

slope_df <- unique(melt_calcify[,c("lake", "description")])
slope_df$slope <- NA
for (i in 1:nrow(slope_df)) {
  lm_df <- melt_calcify %>% 
           filter(.data$date <= as_datetime(mdy("04-30-2019")),
                  .data$lake == slope_df$lake[i],
                  .data$description == slope_df$description[i],
                    .data$variable == "Lake (uM)")
    slope_df$slope[i] <- lm(value ~ date, data = lm_df)$coefficients[2]*
                         NISTunits::NISTyearTOsec(1)
}

plot_obj <- ggplot(melt_calcify) +
            geom_line(aes(x = .data$date, 
                          y = .data$value,
                          color = .data$description)) +
            geom_smooth(data = filter(melt_calcify, 
                                      .data$variable == "Lake (uM)" &
                                      .data$date <= as_datetime(mdy("02-28-2019"))),
                        aes(x = .data$date, y = .data$value, group = .data$description),
                        method = "lm",
                        se = FALSE,
                        color = "grey40", 
                        fullrange = TRUE,
                        linetype = "dashed",
                        size = 0.5) +
            geom_hline(yintercept = 0,
                       color = "black",
                       size = 0.3) +
            geom_text(data = predictions,
                      aes(x = .data$date,
                          y = .data$plot_y,
                          label = .data$value),
                      family = "Segoe UI Semilight") +
            facet_grid(variable~lake, scales = "free", switch = "y") +
            scale_x_datetime(breaks = "2 months",
                             minor_breaks = "1 month",
                             date_labels = "%b",
                             expand = c(0,0)) +
            scale_y_continuous(expand = c(0,0)) +
            labs(x = "", y = "", color = "") +
            theme_bw() +
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  legend.position = "top")
plot_obj
```

## Compare to Solute Mass Balance

So now, given our calculated monthly calcification rates, can we turn that into
a mass flux of Ca lost to calcification? Unfortunately, when we simply sum the
rates and convert from uM to mg/L, net calcification rates are near-zero due to
the negative rates in the winter.

```{r Calc02, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=8.5, fig.height=3.5, fig.align="center"}
# Multiply calcification rates by lake volume
calcify      <- calculate_calcification() %>%
                select(.data$date, .data$lake, .data$description, .data$calcification)
water_fluxes <- calculate_water_balance() %>%
                select(.data$date, .data$lake, .data$mean_vol_m3)
calcify      <- merge(calcify, water_fluxes, by = c("date", "lake"), all.x = TRUE)
calcify$mass_umol <- calcify$calcification*calcify$mean_vol_m3/1000

# Convert units involved in that calculation
ugTOumol <- CSLSchem::mgTOmeq$mgTOmmol[mgTOmeq$description == "CALCIUM TOTAL RECOVERABLE"]
calcify$mass_kg <- calcify$mass_umol/(12*ugTOumol*1000*1000*1000)
calcify  <- calcify %>%
            group_by(.data$date, .data$lake) %>%
            summarise(mass_kg = mean(.data$mass_kg)) %>%
            ungroup() %>% 
            mutate(parameter = "CALCIUM TOTAL RECOVERABLE",
                   site_type = "Cal")

# Combine with other mass fluxes
mass_fluxes <- calculate_solute_balance(solutes = "CALCIUM TOTAL RECOVERABLE")
mass_fluxes <- mass_fluxes %>%
               group_by(lake = .data$lake,
                        parameter = .data$parameter,
                        site_type = .data$site_type) %>%
               summarise(mass_kg = sum(.data$mass_kg)) %>%
               ungroup()
mass_fluxes <- mass_fluxes %>%
               group_by(.data$lake, .data$parameter) %>%
               mutate(pcnt = round(100*.data$mass_kg/
                                     (.data$mass_kg[.data$site_type=="P"]+
                                        .data$mass_kg[.data$site_type=="GWin"]),1)) %>%
               ungroup()

calcify  <- bind_rows(mass_fluxes, calcify) %>%
            filter(.data$parameter == "CALCIUM TOTAL RECOVERABLE")
calcify$site_type <- factor(calcify$site_type,
                            levels = c("P", "GWin", "GWout", "I-O", 
                                       "Delta Lake", "Cal"))
plot_obj <- ggplot(calcify) +
            geom_col(aes(x = .data$site_type,
                         y = .data$mass_kg,
                         fill = .data$site_type)) +
            facet_wrap(~lake, scales = "free") +
            labs(x = "", y = "Solute Mass (kg)") +
            scale_fill_manual(name = "",
                              values = c("#1F78B4", "#33A02C", "#B2DF8A", 
                                         "#FB9A99", "#E31A1C", "#FDBF6F")) +
            theme_bw() +
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),
                  legend.position = "top")
plot_obj
```

<br>

I think McConnaughey didn't actually sum the monthly calcification rates to get
at a new calcification rate though - it seems like they just used that
difference from the regression line. Here's what the mass equivalent of
calcification would be if we use that difference as an annual calcification
rate.

<br>

Still near-zero, which is not at all what we expect. What gives?

```{r Calc03, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=8.5, fig.height=3.5, fig.align="center"}
# Multiply lost calcium by lake volume
Ca_loss <- predictions %>%
           group_by(.data$lake) %>%
           summarise(loss_uM = mean(.data$value)) %>%
           ungroup()
water_fluxes <- calculate_water_balance(annual = TRUE) %>%
                select(.data$lake, .data$mean_vol_m3)
Ca_loss      <- merge(Ca_loss, water_fluxes)
Ca_loss$parameter <- "CALCIUM TOTAL RECOVERABLE"
Ca_loss$site_type <- "Ca Loss"
Ca_loss$mass_umol <- Ca_loss$loss_uM*Ca_loss$mean_vol_m3/1000

# Convert units involved in that calculation
ugTOumol <- CSLSchem::mgTOmeq$mgTOmmol[mgTOmeq$description == "CALCIUM TOTAL RECOVERABLE"]
Ca_loss$mass_kg <- Ca_loss$mass_umol/(12*ugTOumol*1000*1000*1000)

# Combine with other mass fluxes
mass_fluxes <- calculate_solute_balance(solutes = "CALCIUM TOTAL RECOVERABLE")
mass_fluxes <- mass_fluxes %>%
               group_by(lake = .data$lake,
                        parameter = .data$parameter,
                        site_type = .data$site_type) %>%
               summarise(mass_kg = sum(.data$mass_kg)) %>%
               ungroup()
mass_fluxes <- mass_fluxes %>%
               group_by(.data$lake, .data$parameter) %>%
               mutate(pcnt = round(100*.data$mass_kg/
                                     (.data$mass_kg[.data$site_type=="P"]+
                                        .data$mass_kg[.data$site_type=="GWin"]),1)) %>%
               ungroup()

Ca_loss  <- bind_rows(mass_fluxes, Ca_loss) %>%
            filter(.data$parameter == "CALCIUM TOTAL RECOVERABLE")
Ca_loss$site_type <- factor(Ca_loss$site_type,
                            levels = c("P", "GWin", "GWout", "I-O", 
                                       "Delta Lake", "Ca Loss"))
plot_obj <- ggplot(Ca_loss) +
            geom_col(aes(x = .data$site_type,
                         y = .data$mass_kg,
                         fill = .data$site_type)) +
            facet_wrap(~lake, scales = "free") +
            labs(x = "", y = "Solute Mass (kg)") +
            scale_fill_manual(name = "",
                              values = c("#1F78B4", "#33A02C", "#B2DF8A", 
                                         "#FB9A99", "#E31A1C", "#FDBF6F")) +
            theme_bw() +
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),
                  legend.position = "top")
plot_obj
```

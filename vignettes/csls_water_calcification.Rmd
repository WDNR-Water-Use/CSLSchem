---
title: "CSLS Water Chem Visualization: Calcification"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{chem_calcification}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
library(knitr)
library(CSLSchem)
library(dplyr)
library(stringr)
library(lubridate)
library(reshape2)
library(ggplot2)
library(extrafont)
library(stringr)

text_size    <- 12
lakes        <- c("Pleasant", "Long", "Plainfield")
water_chem   <- CSLSdata::water_chem
start_date   <- as_datetime(mdy("10-01-2018"))
end_date     <- as_datetime(mdy("09-30-2019"))

fig_width  <- 6.5
fig_height <- 4
```

## Seasonal Variations in Anions

First, let's look at the data we have about the concentration of major cations
and anions at each lake over time.

<br>

Note that values for Alkalinity, Calcium, and Magnesium are **~50% higher** at
Pleasant and Plainfield Lakes than in McConnaughey et al., while Long Lake is
similar to the values they present for Williams Lake.

```{r cations01, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
# Filter to only anions/cations of interest

parameters <- c("MAGNESIUM TOTAL RECOVERABLE",
                "ALKALINITY TOTAL CACO3",
                "CALCIUM TOTAL RECOVERABLE",
                "SODIUM TOTAL RECOVERABLE",
                "SULFATE TOTAL",
                "CHLORIDE")
plot_names <- c("Mg", "Alkalinity", "Ca", "Na", "SO4", "Cl")

# Get solutes of interest
  C_solutes <- NULL
  for (solute in parameters) {
    C_solute  <- filter_parameter(water_chem, solute)
    C_solute  <- C_solute %>% filter(.data$site_type == "lake")
    C_solute  <- interpolate_chem_values(C_solute, dt = "day") %>%
                 select(.data$lake, .data$date, .data$site_type, .data$result)
    C_solute$description <- solute
    C_solutes <- rbind(C_solutes, C_solute)
  }

# Convert from mg/L to meq/L
ions        <- merge(C_solutes, mgTOmeq, all.x = TRUE)
ions$result <- ions$result*ions$mgTOmeq
ions$lake   <- factor(ions$lake, levels = lakes)

# Sub long descriptions with shorter names for plotting
for (i in 1:length(parameters)) {
  ions$description <- str_replace_all(ions$description,
                                      parameters[i], 
                                      plot_names[i])
}

# Plot
plot_obj <- ggplot(ions) +
            geom_point(aes(x = .data$date, 
                          y = .data$result,
                          color = description),
                      size = 1.5) +
            geom_line(aes(x = .data$date, 
                          y = .data$result,
                          color = description)) +
            facet_grid(~lake) +
            labs(x = "", y = "meq/L") +
            scale_x_datetime(breaks = "6 months",
                             minor_breaks = "2 months",
                             date_labels = "%b-%y") +
            scale_color_brewer(name = "",
                               palette = "Set2") +
            theme_bw() + 
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  legend.position = "top")
plot_obj

```

<br>

Next, let's look at monthly values of the major cations (Mg++, Ca++, Na+, and
K+) for Oct 2018 - Sept 2019 realative to the mean Jan/Feb values. The goal of
this is to visually identify cations which drop during spring dilution,
stabilize over the summer, then rise over winter. This would indicate that, to a
first approximation, seasonal fluctuations in those cations reflect dilution.

<br>

None of the cations are very conservative, but **at a first approximation, Mg or
Na are the most conservative** in all lakes.

```{r cations, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
# Filter to only anions/cations of interest

parameters <- c("MAGNESIUM TOTAL RECOVERABLE",
                "SODIUM TOTAL RECOVERABLE",
                "CALCIUM TOTAL RECOVERABLE",
                "POTASSIUM TOTAL RECOVERABLE")
plot_names <- c("Mg", "Na", "Ca", "K")

# Get solutes of interest
C_solutes <- NULL
for (solute in parameters) {
  C_solute  <- filter_parameter(water_chem, solute)
  C_solute  <- C_solute %>% filter(.data$site_type == "lake")
  C_solute  <- interpolate_chem_values(C_solute, dt = "day") %>%
    select(.data$lake, .data$date, .data$site_type, .data$result)
  C_solute$description <- solute
  C_solutes <- rbind(C_solutes, C_solute)
}
  
# Convert from mg/L to meq/L
ions        <- merge(C_solutes, mgTOmeq, all.x = TRUE)
ions$result <- ions$result*ions$mgTOmeq
ions$lake   <- factor(ions$lake, levels = lakes)

# Sub long descriptions with shorter names for plotting
for (i in 1:length(parameters)) {
  ions$description <- str_replace_all(ions$description,
                                      parameters[i], 
                                      plot_names[i])
}

# Find monthly average values across entire timeseries
ions <- ions %>%
        filter(.data$date >= start_date,
               .data$date <= end_date) %>%
        select(.data$lake, .data$date, .data$description, .data$result)

# Compare to mean Jan/Feb values
mean_ions   <- ions %>%
               filter(month(.data$date) %in% c(1, 2)) %>%
               group_by(.data$lake, .data$description) %>%
               summarise(mean = mean(.data$result, na.rm = TRUE)) %>%
               ungroup()
ions        <- merge(ions, mean_ions, by = c("lake", "description"))
ions$result <- ions$result/ions$mean

# Plot
plot_obj <- ggplot(ions) +
            geom_line(aes(x = date, 
                          y = result,
                          color = description),
                      size = 1) +
            facet_grid(~lake) +
            labs(x = "", y = "%(Jan,Feb) value") +
            scale_x_datetime(expand = c(0,0),
                             breaks = "2 months",
                             minor_breaks = "1 month",
                             date_labels = "%b") +
            scale_y_continuous(breaks = 0.1*c(5:12),
                               labels = scales::percent_format(accuracy = 1)) +
            scale_color_brewer(name = "",
                               palette = "Set2") +
            theme_bw() + 
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  legend.position = "top")
plot_obj

```

## Pairwise Comparisons

Pairwise comparisons can be used to further investigate quasi-conservative
behavior of cations/anions. Lake-water values for semi-conservative ions should
fall near a dilution line connecting most upgradient groundwater samples with
precipitation samples.

In these plots, PFL-09 (a well with unusually high cations/anions) is not shown.

### Mg vs. Ca

Here, we're comparing Magnesium vs. Calcium.

```{r MgCa, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "CALCIUM TOTAL RECOVERABLE"),
           text_size = text_size)
```


### Mg vs. Na

Here, we're comparing Magnesium vs. Sodium

```{r MgNa, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "SODIUM TOTAL RECOVERABLE"),
           text_size = text_size)
```

### Mg vs. K

Here, we're comparing Magnesium vs. Potassium

```{r MgK, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "POTASSIUM TOTAL RECOVERABLE"),
           text_size = text_size)
```

### Mg vs. Cl

Here, we're comparing Magnesium vs. Chloride

```{r MgCl, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "CHLORIDE"),
           text_size = text_size)
```

### Mg vs. Alk

Here, we're comparing Magnesium vs. Alkalinity

```{r MgAlk, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=fig_height, fig.align="center"}
plot_pairs(water_chem, 
           parameters = c("MAGNESIUM TOTAL RECOVERABLE", 
                          "ALKALINITY TOTAL CACO3"),
           text_size = text_size)
```

## Calcification

Ok, so now let's see how much calcification we might expect based on the
approach by McConnaughey et al., 1994. A few notes:

 * Regressions cover the period Oct-Apr, as in McConnaughey et al., but in our
 lakes, it looks like Ca/Alk only increase Oct-Feb. Changing the time period
 used for the regression line would increase these differences. 
 * The slope of the regression line for Williams Lake was ~120 uM/yr, these are
 ~126 uM/yr (Long), 207 uM/yr (Pleasant), and 322 uM/yr (Plainfield).
 * The text lables represent the difference (in uM) between the projected Alk/Ca
 values and the observed values for the lowest point in the summer (Jun for
 Long, Jul for Plainfield, Aug for Pleasant). The difference at Williams Lake
 was ~160 uM.
 * I've gotten all turned around on what "dilution-normalized" means in terms of
 lake concentrations. These values are not transformed - they are simply the
 Ca/Alk concentrations in the lake.

```{r Calc, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=fig_width, fig.height=5, fig.align="center"}
# Calculate calcification
calcify <- calculate_calcification() %>%
           select(.data$date, .data$lake, .data$description,
                  .data$calcification, .data$X_lake)
colnames(calcify) <- c("date", "lake", "description", 
                       "Calcification (uM/yr)", "Lake (uM)")

# Rearrange and rename
melt_calcify <- melt(calcify, id.vars = c("date", "lake", "description"))
melt_calcify$description <- str_replace_all(melt_calcify$description, 
                                           "ALKALINITY TOTAL CACO3", 
                                           "Alkalinity")
melt_calcify$description <- str_replace_all(melt_calcify$description, 
                                           "CALCIUM TOTAL RECOVERABLE", 
                                           "Calcium")
melt_calcify$variable <- factor(melt_calcify$variable, 
                               levels = c("Lake (uM)", "Calcification (uM/yr)"))

predictions <- NULL
for (pred_date in c("06-01-2019", "07-01-2019", "08-01-2019")) {
this_date <- melt_calcify %>%
             filter(.data$date <= as_datetime(mdy("04-30-2019")),
                    .data$variable == "Lake (uM)") %>%
             group_by(.data$lake, .data$description) %>%
             do(lm(value ~ date, data = .) %>%
                  predict(., data.frame(date = as_datetime(mdy(pred_date)))) %>%
                  data_frame(date = as_datetime(mdy(pred_date)), value = .)) %>%
             ungroup()
predictions <- bind_rows(predictions, this_date)
}
predictions$variable <- "Lake (uM)"
predictions <- merge(predictions, 
                     melt_calcify, 
                     by = c("date", "lake", "description", "variable"),
                     all.x = TRUE)
predictions <- predictions %>%
               mutate(value = round(.data$value.x - .data$value.y, digits = 2),
                      plot_y = .data$value.y + 0.5*.data$value)

predictions <- predictions %>%
               filter((.data$date == as_datetime(mdy("06-01-2019")) & 
                         .data$lake == "Long") |
                        (.data$date == as_datetime(mdy("07-01-2019")) & 
                           .data$lake == "Plainfield") |
                        (.data$date == as_datetime(mdy("08-01-2019")) & 
                           .data$lake == "Pleasant"))

slope_df <- unique(melt_calcify[,c("lake", "description")])
slope_df$slope <- NA
for (i in 1:nrow(slope_df)) {
  lm_df <- melt_calcify %>% 
           filter(.data$date <= as_datetime(mdy("04-30-2019")),
                  .data$lake == slope_df$lake[i],
                  .data$description == slope_df$description[i],
                    .data$variable == "Lake (uM)")
    slope_df$slope[i] <- lm(value ~ date, data = lm_df)$coefficients[2]*
                         NISTunits::NISTyearTOsec(1)
}

plot_obj <- ggplot(melt_calcify) +
            geom_line(aes(x = .data$date, 
                          y = .data$value,
                          color = .data$description)) +
            geom_smooth(data = filter(melt_calcify, 
                                      .data$variable == "Lake (uM)" &
                                      .data$date <= as_datetime(mdy("02-28-2019"))),
                        aes(x = .data$date, y = .data$value, group = .data$description),
                        method = "lm",
                        se = FALSE,
                        color = "grey40", 
                        fullrange = TRUE,
                        linetype = "dashed",
                        size = 0.5) +
            geom_hline(yintercept = 0,
                       color = "black",
                       size = 0.3) +
            geom_text(data = predictions,
                      aes(x = .data$date,
                          y = .data$plot_y,
                          label = .data$value),
                      family = "Segoe UI Semilight") +
            facet_grid(variable~lake, scales = "free", switch = "y") +
            scale_x_datetime(breaks = "2 months",
                             minor_breaks = "1 month",
                             date_labels = "%b",
                             expand = c(0,0)) +
            scale_y_continuous(expand = c(0,0)) +
            labs(x = "", y = "", color = "") +
            theme_bw() +
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  legend.position = "top")
plot_obj
```

## Compare to Solute Mass Balance

Here's how the caclulated calcification ("Cal", mean of Ca & Alk approaches)
compares to the rest of the calcium solute balance. 

<br>

Net calcification rates are near-zero due to the negative rates in the winter.

```{r Calc02, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=8.5, fig.height=5, fig.align="center"}
# Multiply calcification rates by lake volume
calcify      <- calculate_calcification() %>%
                select(.data$date, .data$lake, .data$description, .data$calcification)
water_fluxes <- calculate_water_balance() %>%
                select(.data$date, .data$lake, .data$mean_vol_m3)
calcify      <- merge(calcify, water_fluxes, by = c("date", "lake"), all.x = TRUE)
calcify$mass_umol <- calcify$calcification*calcify$mean_vol_m3/1000

# Convert units involved in that calculation
ugTOumol <- CSLSchem::mgTOmeq$mgTOmmol[mgTOmeq$description == "CALCIUM TOTAL RECOVERABLE"]
calcify$mass_kg <- calcify$mass_umol/(12*ugTOumol*1000*1000*1000)
calcify  <- calcify %>%
            group_by(.data$date, .data$lake) %>%
            summarise(mass_kg = mean(.data$mass_kg)) %>%
            ungroup() %>% 
            mutate(parameter = "CALCIUM TOTAL RECOVERABLE",
                   site_type = "Cal")

# Combine with other mass fluxes
mass_fluxes <- calculate_solute_balance()
mass_fluxes <- mass_fluxes %>%
               group_by(lake = .data$lake,
                        parameter = .data$parameter,
                        site_type = .data$site_type) %>%
               summarise(mass_kg = sum(.data$mass_kg)) %>%
               ungroup()
mass_fluxes <- mass_fluxes %>%
               group_by(.data$lake, .data$parameter) %>%
               mutate(pcnt = round(100*.data$mass_kg/
                                     (.data$mass_kg[.data$site_type=="P"]+
                                        .data$mass_kg[.data$site_type=="GWin"]),1)) %>%
               ungroup()

calcify  <- bind_rows(mass_fluxes, calcify) %>%
            filter(.data$parameter == "CALCIUM TOTAL RECOVERABLE")
calcify$site_type <- factor(calcify$site_type,
                            levels = c("P", "GWin", "GWout", "I-O", 
                                       "Delta Lake", "Cal"))
plot_obj <- ggplot(calcify) +
            geom_col(aes(x = .data$site_type,
                         y = .data$mass_kg,
                         fill = .data$site_type)) +
            facet_wrap(~lake, scales = "free") +
            labs(x = "", y = "Solute Mass (kg)") +
            scale_fill_manual(name = "",
                              values = c("#1F78B4", "#33A02C", "#B2DF8A", 
                                         "#FB9A99", "#E31A1C", "#FDBF6F")) +
            theme_bw() +
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),
                  legend.position = "top")
plot_obj
```

<br>

I think McConnaughey didn't actually sum the monthly calcification rates to get
at a new calcification rate though - it seems like they just used that
difference from the regression line. They accounted for fall dissolution (and
I'm not, so my values represent an overestimate), but here's what the mass
equivalent of calcification would be if we use that difference.

<br>

Still near-zero.

```{r Calc03, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, fig.width=8.5, fig.height=5, fig.align="center"}
# Multiply lost calcium by lake volume
Ca_loss <- predictions %>%
           group_by(.data$lake) %>%
           summarise(loss_uM = mean(.data$value)) %>%
           ungroup()
water_fluxes <- calculate_water_balance(annual = TRUE) %>%
                select(.data$lake, .data$mean_vol_m3)
Ca_loss      <- merge(Ca_loss, water_fluxes)
Ca_loss$parameter <- "CALCIUM TOTAL RECOVERABLE"
Ca_loss$site_type <- "Ca Loss"
Ca_loss$mass_umol <- Ca_loss$loss_uM*Ca_loss$mean_vol_m3/1000

# Convert units involved in that calculation
ugTOumol <- CSLSchem::mgTOmeq$mgTOmmol[mgTOmeq$description == "CALCIUM TOTAL RECOVERABLE"]
Ca_loss$mass_kg <- Ca_loss$mass_umol/(12*ugTOumol*1000*1000*1000)

# Combine with other mass fluxes
mass_fluxes <- calculate_solute_balance()
mass_fluxes <- mass_fluxes %>%
               group_by(lake = .data$lake,
                        parameter = .data$parameter,
                        site_type = .data$site_type) %>%
               summarise(mass_kg = sum(.data$mass_kg)) %>%
               ungroup()
mass_fluxes <- mass_fluxes %>%
               group_by(.data$lake, .data$parameter) %>%
               mutate(pcnt = round(100*.data$mass_kg/
                                     (.data$mass_kg[.data$site_type=="P"]+
                                        .data$mass_kg[.data$site_type=="GWin"]),1)) %>%
               ungroup()

Ca_loss  <- bind_rows(mass_fluxes, Ca_loss) %>%
            filter(.data$parameter == "CALCIUM TOTAL RECOVERABLE")
Ca_loss$site_type <- factor(Ca_loss$site_type,
                            levels = c("P", "GWin", "GWout", "I-O", 
                                       "Delta Lake", "Ca Loss"))
plot_obj <- ggplot(Ca_loss) +
            geom_col(aes(x = .data$site_type,
                         y = .data$mass_kg,
                         fill = .data$site_type)) +
            facet_wrap(~lake, scales = "free") +
            labs(x = "", y = "Solute Mass (kg)") +
            scale_fill_manual(name = "",
                              values = c("#1F78B4", "#33A02C", "#B2DF8A", 
                                         "#FB9A99", "#E31A1C", "#FDBF6F")) +
            theme_bw() +
            theme(text = element_text(family = "Segoe UI Semilight",
                                      size = text_size),
                  panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),
                  legend.position = "top")
plot_obj
```
